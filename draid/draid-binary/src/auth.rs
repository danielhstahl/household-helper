use crate::psql_users::get_user;
use jsonwebtoken::{Algorithm, DecodingKey, EncodingKey, Header, Validation, decode, encode};
use poem::error::InternalServerError;
use poem::http::header::AUTHORIZATION;
use poem::{Endpoint, Middleware, Request, Result};
use serde::{Deserialize, Serialize};
use sqlx::PgPool;
use std::fmt;
use uuid::Uuid;
// Used for integration with custom middleware
use poem_grants::authorities::AttachAuthorities;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone)]
pub struct UserIdentification {
    pub username: String,
    pub id: Uuid,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    // The subject of the token (the user's ID or username)
    pub sub: String,
    // Issued at (as a timestamp)
    pub iat: u64,
    // Expiration time (as a timestamp)
    pub exp: u64,
}

#[derive(Debug)]
pub struct AuthError {
    msg: String,
}
impl fmt::Display for AuthError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.msg)
    }
}
impl std::error::Error for AuthError {}

pub fn create_token(username: String, jwt_secret: &[u8]) -> Result<String, AuthError> {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();
    let claims = Claims {
        sub: username,
        iat: now,
        exp: now + (60 * 30), // 30 minutes expiration
    };

    encode(
        &Header::new(Algorithm::HS256),
        &claims,
        &EncodingKey::from_secret(jwt_secret),
    )
    .map_err(|e| AuthError { msg: e.to_string() })
}

/// A middleware that extract token from HTTP headers. See https://docs.rs/poem/latest/poem/middleware/trait.Middleware.html
pub struct JwtMiddleware;

impl<E: Endpoint> Middleware<E> for JwtMiddleware {
    type Output = JwtMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        JwtMiddlewareImpl { ep }
    }
}

/// The new endpoint type generated by the TokenMiddleware.
pub struct JwtMiddlewareImpl<E> {
    ep: E,
}

impl<E: Endpoint> Endpoint for JwtMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, mut req: Request) -> Result<Self::Output> {
        let jwt_secret = req.data::<Vec<u8>>().ok_or_else(|| {
            InternalServerError(AuthError {
                msg: "JWT Secret does not exist".to_string(),
            })
        })?;
        let pool = req.data::<PgPool>().ok_or_else(|| {
            InternalServerError(AuthError {
                msg: "Could not get database connection".to_string(),
            })
        })?;
        if let Some(value) = req
            .headers()
            .get(AUTHORIZATION)
            .and_then(|value| value.to_str().ok())
            .filter(|value| value.starts_with("Bearer "))
            .map(|value| &value[7..])
        {
            let token_data = decode::<Claims>(
                value,
                &DecodingKey::from_secret(jwt_secret),
                &Validation::new(Algorithm::HS256),
            )
            .map_err(InternalServerError)?;
            let calling_user = get_user(&token_data.claims.sub, pool)
                .await
                .map_err(InternalServerError)?;

            req.extensions_mut().insert(UserIdentification {
                username: calling_user.username,
                id: calling_user.id,
            });
            // Attach permissions to request for `poem-grants`
            req.attach(calling_user.roles);
        }

        // call the next endpoint.
        self.ep.call(req).await
    }
}
